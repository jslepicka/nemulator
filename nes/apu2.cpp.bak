#include "apu2.h"
#include <memory>
#include <assert.h>
#include "nes.h"
#include "cpu.h"
#include "fir_coefs.h"
#include "apu_luts.h"
#include <emmintrin.h>
//#define AUDIO_LOG 1
#ifdef AUDIO_LOG
std::ofstream file;
#endif

c_apu2::c_apu2(void)
{
	reset();
	squares[0] = &square1;
	squares[1] = &square2;
	mixer_enabled = 1;
#ifdef AUDIO_LOG
	file.open("c:\\log\\audio.out", std::ios_base::trunc | std::ios_base::binary);
#endif
}

c_apu2::~c_apu2(void)
{
#ifdef AUDIO_LOG
	file.close();
#endif
}

void c_apu2::enable_mixer()
{
	mixer_enabled = 1;
}

void c_apu2::disable_mixer()
{
	mixer_enabled = 0;
}

void c_apu2::set_nes(c_nes *nes)
{
	this->nes = nes;
	dmc.set_nes(nes);
};

void c_apu2::reset()
{
	ticks = 0;
	frame_seq_counter = 0;
	int x = sizeof(reg);
	for (int i = 0; i < sizeof(reg); i++)
		reg[i] = 0;
	frame_seq_step = 0;
	frame_seq_steps = 4;
	x = sizeof(raw_buf);
	memset(raw_buf, 0, sizeof(raw_buf));
	raw_buf_index = 0;
	num_samples = 0;
	M = 0; //decimation factor
	x = sizeof(sample_buf);
	memset(sample_buf, 0, sizeof(sample_buf));
	square1.set_sweep_mode(1);
	frame_irq_enable = 0;
	frame_irq_flag = 0;
	frame_irq_asserted = 0;
	square1.reset();
	square2.reset();
	triangle.reset();
	noise.reset();
	dmc.reset();
	last_amp = 0.0;
	last_out = 0.0;
}

void c_apu2::write_byte(unsigned short address, unsigned char value)
{
	reg[address-0x4000] = value;
	switch (address - 0x4000)
	{
	case 0x0:
	case 0x1:
	case 0x2:
	case 0x3:
	case 0x4:
	case 0x5:
	case 0x6:
	case 0x7:
		squares[(address & 0x4) >> 2]->write(address, value);
		break;
	case 0x8:
	case 0xA:
	case 0xB:
		triangle.write(address, value);
		break;
	case 0xC:
	case 0xE:
	case 0xF:
		noise.write(address, value);
		break;
	case 0x10:
	case 0x11:
	case 0x12:
	case 0x13:
		dmc.write(address, value);
		break;
	case 0x15:
		if (value & 0x1)
			square1.enable();
		else
			square1.disable();
		if (value & 0x2)
			square2.enable();
		else
			square2.disable();
		if (value & 0x4)
			triangle.enable();
		else
			triangle.disable();
		if (value & 0x8)
			noise.enable();
		else
			noise.disable();
		if (value & 0x10)
			dmc.enable();
		else
			dmc.disable();
		dmc.ack_irq();
		break;
	case 0x17:
		{
			frame_irq_enable = !(value & 0x40);

			frame_seq_step = 0;
			frame_seq_counter = 0;
			if (value & 0x80)
			{
				frame_seq_steps = 5;
				clock_frame_seq();
			}
			else
			{
				frame_seq_steps = 4;
			}
		}
		break;
	default:
		{
			int d = 1;
		}
	}
}

unsigned char c_apu2::read_byte(unsigned short address)
{
	//can only read 0x4015
	if (address == 0x4015)
	{
		int retval = 0;
		retval |= square1.get_status();
		retval |= (square2.get_status() << 1);
		retval |= (triangle.get_status() << 2);
		retval |= (noise.get_status() << 3);
		retval |= (dmc.get_status() << 4);
		retval |= (dmc.get_irq_flag() << 7);
		retval |= ((frame_irq_flag ? 1 : 0) << 6);

		if (frame_irq_flag)
		{
			frame_irq_flag = 0;
			if (frame_irq_asserted)
			{
				nes->cpu->clear_irq();
				frame_irq_asserted = 0;
			}
		}

		return retval;

	}
	return reg[address-0x4000];
}

void c_apu2::clock(int cycles)
{
	ticks += cycles;

	while (ticks > 2) //1 cpu cycle
	{
		frame_seq_counter += 12;
		if (frame_seq_counter >= 89490)
		{
			frame_seq_counter -= 89490;
			clock_frame_seq();
		}
		clock_timers();
		if (mixer_enabled)
			mix();
		ticks -= 3;
	}
}

float c_apu2::blockdc(float sample)
{
	//a = ((pi*2*cutoff_freq)/sample_rate)
	float output = sample - last_amp + 0.996 * last_out;
	last_amp = sample;
	last_out = output;

	return output;
}

void c_apu2::mix()
{
	float sample = 0.0;
	int square_vol = square1.get_output() + square2.get_output();
	//square_vol = square1.get_output();
	//double square_out = 0.0;
	//if (square_vol > 0)
	//{
	//	square_out = 95.88 / ((8128.0 / square_vol) + 100.0);	
	//}
	float square_out = square_lut[square_vol];

	int triangle_vol = triangle.get_output();
	int noise_vol = noise.get_output();
	int dmc_vol = dmc.get_output();
	//triangle_vol = 0;
	//double tnd_out = 0.0;
	//if (triangle_vol + noise_vol + dmc_vol != 0)
	//{
	//	tnd_out = 159.79 / ((1.0/((triangle_vol/8227.0) + (noise_vol/12241.0) + (dmc_vol/22638.0))) + 100.0);
	//}

	float tnd_out = tnd_lut [3 * triangle_vol + 2 * noise_vol + dmc_vol];

	sample = square_out + tnd_out;

	raw_buf[raw_buf_index] = raw_buf[raw_buf_index + raw_buf_len/2] = sample;
	//raw_buf_index = ++raw_buf_index % raw_buf_len;

	if (++M == 37)
	{
		//todo: figure out mixing for external audio
		static const float max_out = 32767.0;//65535.0;
		int s = (int)((blockdc(filter_hq2()) * max_out)/* - 32768.0*/);
		//short s = filter_hq() * 65535.0;
		if (s > 32767)
			s = 32767;
		else if (s < -32768)
			s = -32768;

#ifdef AUDIO_LOG
		char buf[32] = {0};
		sprintf(buf, "%d\n", s);
		file.write(buf, strlen(buf));
		file.flush();
#endif
		M = 0;
		sample_buf[num_samples++] = (short)s;
	}
	raw_buf_index--;
	if (raw_buf_index < 0)
		raw_buf_index = (raw_buf_len/2) - 1;
}

float c_apu2::filter_hq2()
{
	int buf_index = raw_buf_index;
	int newest = buf_index;
	int oldest = buf_index + 512;
	float* n_buf = &raw_buf[newest];
	float* o_buf = &raw_buf[oldest];

	float sum = n_buf[256] * fir512[256];
	for (int i = 0; i < 256; i++)
		sum += (n_buf[i] + o_buf[0-i]) * fir512[i];

	if (sum < 0.0)
		sum = 0.0;
	else if (sum > 1.0)
		sum = 1.0;

	return sum;
}

int c_apu2::get_num_samples()
{
	int x = num_samples;
	num_samples = 0;
	return x;
}

void c_apu2::clock_timers()
{
	square1.clock_timer();
	square2.clock_timer();
	triangle.clock_timer();
	noise.clock_timer();
	dmc.clock_timer();
}

void c_apu2::clock_envelopes()
{
	square1.clock_envelope();
	square2.clock_envelope();
	triangle.clock_linear();
	noise.clock_envelope();
}

void c_apu2::clock_length_sweep()
{
	square1.clock_length_sweep();
	square2.clock_length_sweep();
	triangle.clock_length();
	noise.clock_length();
}

void c_apu2::clock_frame_seq()
{
	//frame_irq_flag = 0;
	if (frame_seq_steps == 5)
	{
		switch (frame_seq_step)
		{
		case 0:
			clock_envelopes();
			clock_length_sweep();
			break;
		case 1:
			clock_envelopes();
			break;
		case 2:
			clock_envelopes();
			clock_length_sweep();
			break;
		case 3:
			clock_envelopes();
			break;
		case 4:
			break;
		}
	}
	else
	{
		//clock envelopes and triangle linear counter
		switch (frame_seq_step)
		{
		case 0:
			clock_envelopes();
			break;
		case 1:
			clock_envelopes();
			clock_length_sweep();
			break;
		case 2:
			clock_envelopes();
			break;
		case 3:
			clock_envelopes();
			clock_length_sweep();
			//if irq flag, and !irq disable, execute interrupt
			frame_irq_flag = 1;
			if (frame_irq_flag && frame_irq_enable && !frame_irq_asserted)
			{
				frame_irq_asserted = 1;
				nes->cpu->execute_irq();
			}
			break;
		}
	}

	frame_seq_step = ++frame_seq_step % frame_seq_steps;
	int x = 1;
}

c_apu2::c_envelope::c_envelope()
{
	reset();
}

c_apu2::c_envelope::~c_envelope()
{
}

void c_apu2::c_envelope::reset()
{
	reset_flag = 0;
	counter = 1;
	output = 0;
	period = 1;
	enabled = 0;
	loop = 0;
	env_vol = 0;
}

void c_apu2::c_envelope::clock()
{
	if (reset_flag)
	{
		reset_flag = 0;
		env_vol = 15;
		counter = period;
	}
	else if (--counter == 0)
	{
		if (env_vol || loop)
			env_vol = (env_vol - 1) & 0xF;
		counter = period;
	}

	if (enabled)
		output = env_vol;
}

void c_apu2::c_envelope::write(unsigned char value)
{
	period = (value & 0xF) + 1;
	enabled = !(value & 0x10);
	loop = value & 0x20;
	output = enabled ? env_vol : value & 0xF;
}

void c_apu2::c_envelope::reset_counter()
{
	reset_flag = 1;
}

int c_apu2::c_envelope::get_output()
{
	return output;
}

c_apu2::c_timer::c_timer()
{
	reset();
}

c_apu2::c_timer::~c_timer()
{
}

void c_apu2::c_timer::reset()
{
	period = 1;
	counter = 1;
	output = 0;
}

void c_apu2::c_timer::clock(int shift)
{
	if (--counter == 0)
	{
		counter = (period + 1) << shift;
		output = 1;
	}
	else
	{
		output = 0;
	}
}

void c_apu2::c_timer::set_period_lo(int period_lo)
{
	period = (period & 0x0700) | (period_lo & 0xFF);
}

void c_apu2::c_timer::set_period_hi(int period_hi)
{
	period = (period & 0xFF) | ((period_hi & 0x7) << 8);
}

int c_apu2::c_timer::get_period()
{
	return period;
}

int c_apu2::c_timer::get_output()
{
	return output;
}

void c_apu2::c_timer::set_period(int value)
{
	period = value;
}

c_apu2::c_sequencer::c_sequencer()
{
	reset();
}

c_apu2::c_sequencer::~c_sequencer()
{
}

void c_apu2::c_sequencer::reset()
{
	duty_cycle = 0;
	step = 0;
	output = 0;
	ticks = 0;
}

int c_apu2::c_sequencer::get_output()
{
	return duty_cycle_table[duty_cycle][step];
}

void c_apu2::c_sequencer::reset_step()
{
	step = 0;
	//TODO: silence output?
	//output = 0;
}

void c_apu2::c_sequencer::set_duty_cycle(int duty)
{
	duty_cycle = duty & 0x3;
}

const int c_apu2::c_sequencer::duty_cycle_table[4][8] = {
	{0, 1, 0, 0, 0, 0, 0, 0},
	{0, 1, 1, 0, 0, 0, 0, 0},
	{0, 1, 1, 1, 1, 0, 0, 0},
	{1, 0, 0, 1, 1, 1, 1, 1}
};

void c_apu2::c_sequencer::clock()
{
	step = --step & 0x7;
	//switch (duty_cycle)
	//{
	//case 0:
	//	if (step == 1)
	//		output = 1;
	//	else
	//		output = 0;
	//	break;
	//case 1:
	//	if (step == 1 || step == 2)
	//		output = 1;
	//	else
	//		output = 0;
	//	break;
	//case 2:
	//	if (step >= 1 && step <= 4)
	//		output = 1;
	//	else
	//		output = 0;
	//	break;
	//case 3:
	//	if (step == 1 || step == 2)
	//		output = 0;
	//	else
	//		output = 1;
	//	break;
	//}
}

c_apu2::c_length::c_length()
{
	reset();
}

c_apu2::c_length::~c_length()
{
}

void c_apu2::c_length::reset()
{
	counter = 0;
	halt = 0;
	length = 0;
	enabled = 0;
}

void c_apu2::c_length::clock()
{
	if (!halt && counter != 0)
		counter--;
}

int c_apu2::c_length::get_output()
{
	return counter;
}

int c_apu2::c_length::get_counter()
{
	return counter;
}

void c_apu2::c_length::set_halt(int halt)
{
	this->halt = halt;
}

void c_apu2::c_length::enable()
{
	enabled = 1;
}

void c_apu2::c_length::disable()
{
	enabled = 0;
	counter = 0;
}

int c_apu2::c_length::get_halt()
{
	return halt;
}

const int c_apu2::c_length::length_table[32] = 
{
	0x0A, 0xFE, 0x14, 0x02, 0x28, 0x04, 0x50, 0x06,
	0xA0, 0x08, 0x3C, 0x0A, 0x0E, 0x0C, 0x1A, 0x0E,
	0x0C, 0x10, 0x18, 0x12, 0x30, 0x14, 0x60, 0x16,
	0xC0, 0x18, 0x48, 0x1A, 0x10, 0x1C, 0x20, 0x1E
};

void c_apu2::c_length::set_length(int index)
{
	if (enabled)
		counter = length_table[index & 0x1F];
}

c_apu2::c_square::c_square()
{
	reset();
}

void c_apu2::c_square::reset()
{
	output = 0;
	sweep_reg = 0;
	sweep_period = 0;
	sweep_reset = 0;
	sweep_enable = 0;
	sweep_negate = 0;
	sweep_shift = 0;
	sweep_output = 1;
	sweep_mode = 0;
	sweep_counter = 1;
	envelope.reset();
	timer.reset();
	sequencer.reset();
	length.reset();
}

c_apu2::c_square::~c_square()
{
}

void c_apu2::c_square::clock_timer()
{
	timer.clock(1);
	if (timer.get_output())
		sequencer.clock();
}

void c_apu2::c_square::clock_envelope()
{
	envelope.clock();
}

void c_apu2::c_square::clock_length_sweep()
{
	length.clock();
	if (sweep_enable)
	{
		int d = 1;
	}
	int period = timer.get_period();
	if (sweep_period != 0 && --sweep_counter == 0)
	{
		sweep_counter = sweep_period;
		if (period >= 8)
		{
			sweep_output = 1;
			int offset = period >> sweep_shift;
			if (sweep_negate)
			{
				if (sweep_shift && sweep_enable)
					timer.set_period(period + ((-1 * sweep_mode) - offset));
			}
			else 
			{
				if (period + offset < 0x800)
				{
					if (sweep_shift && sweep_enable)
						timer.set_period(period + offset);
				}
			}
		}
	}
	if (sweep_reset)
	{
		sweep_reset = 0;
		sweep_counter = sweep_period;
	}
}

int c_apu2::c_square::get_output()
{
	int vol = envelope.get_output();
	int period = timer.get_period();
	int sweep_silencing = ((period < 8) || ((period + (period >> sweep_shift)) > 0x7FF));

	if (vol && sequencer.get_output() && !sweep_silencing && length.get_output())
	{
		return vol;
	}
	return 0;
}

void c_apu2::c_square::write(unsigned short address, unsigned char value)
{
	switch (address & 0x3)
	{
	case 0x0:
		length.set_halt((value & 0x20) >> 5);
		envelope.write(value);
		sequencer.set_duty_cycle(value >> 6);
		break;
	case 0x1:
		sweep_enable = value & 0x80;
		sweep_negate = value & 0x8;
		sweep_shift = value & 0x7;
		sweep_period = 0;
		sweep_period = ((value & 0x70) >> 4) + 1;
		sweep_reset = 1;
		break;
	case 0x2:
		timer.set_period_lo(value);
		break;
	case 0x3:
		sequencer.reset_step();
		timer.set_period_hi(value);
		length.set_length((value >> 3) & 0x1F);
		envelope.reset_counter();
		break;
	}
}

void c_apu2::c_square::enable()
{
	length.enable();
}

void c_apu2::c_square::disable()
{
	length.disable();
}

int c_apu2::c_square::get_status()
{
	return length.get_counter() ? 1 : 0;
}

void c_apu2::c_square::set_sweep_mode(int mode)
{
	sweep_mode = mode & 0x1;
}

const int c_apu2::c_triangle::sequence[32] = {
	0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0,
	0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF
};

c_apu2::c_triangle::c_triangle()
{
	reset();
}

c_apu2::c_triangle::~c_triangle()
{
}

void c_apu2::c_triangle::reset()
{
	output = 0;
	sequence_pos = 0;
	linear_counter = 0;
	linear_reload = 0;
	length_enabled = 0;
	linear_control = 0;
	linear_halt = 0;
	timer.reset();
	length.reset();
}

void c_apu2::c_triangle::clock_timer()
{
	//               +---------+    +---------+
	//               |LinearCtr|    | Length  |
	//               +---------+    +---------+
	//                    |              |
	//                    v              v
	//+---------+        |\             |\         +---------+    +---------+ 
	//|  Timer  |------->| >----------->| >------->|Sequencer|--->|   DAC   |
	//+---------+        |/             |/         +---------+    +---------+ 

	timer.clock(0);
	if (timer.get_output())
	{
		if (length.get_output() && linear_counter)
		{
			output = sequence[sequence_pos];
			sequence_pos = ++sequence_pos % 32;
			//need this for crappy output filter otherwise freq is too high
			//and causes aliasing
			//if (timer.get_period() < 2)
			//	output = 0x7;
		}
	}
}

void c_apu2::c_triangle::enable()
{
	length.enable();
}

void c_apu2::c_triangle::disable()
{
	length.disable();
}

void c_apu2::c_triangle::write(unsigned short address, unsigned char value)
{
	switch (address - 0x4000)
	{
	case 0x8:
		length_enabled = !(value & 0x80);
		linear_control = (value & 0x80);
		linear_reload = (value & 0x7F);
		length.set_halt((value & 0x80) >> 7);
		break;
	case 0xA:	
		timer.set_period_lo(value);
		break;
	case 0xB:
		linear_halt = 1;
		timer.set_period_hi(value & 0x7);
		length.set_length(value >> 3);
		length.set_halt(1);
		break;
	default:
		break;
	}
}

int c_apu2::c_triangle::get_output()
{
	return output;
}

int c_apu2::c_triangle::get_status()
{
	return length.get_counter() ? 1 : 0;
}

void c_apu2::c_triangle::clock_length()
{
	length.clock();
}

void c_apu2::c_triangle::clock_linear()
{
	if (linear_halt)
	{
		linear_counter = linear_reload;
	}
	else if (linear_counter != 0)
	{
		linear_counter--;
	}
	if (!linear_control)
	{
		linear_halt = 0;
	}
}

c_apu2::c_noise::c_noise()
{
	reset();
}

c_apu2::c_noise::~c_noise()
{
}

void c_apu2::c_noise::reset()
{
	output = 0;
	short_mode = 0;
	random_period = 0;
	random_counter = 0;
	length_enabled = 0;
	lfsr = 0x1;
	length.reset();
	envelope.reset();
	timer.reset();
}

const int c_apu2::c_noise::random_period_table[16] = {
	0x004, 0x008, 0x010, 0x020, 0x040, 0x060, 0x080, 0x0A0,
	0x0CA, 0x0FE, 0x17C, 0x1FC, 0x2FA, 0x3F8, 0x7F2, 0xFE4
};

void c_apu2::c_noise::write(unsigned short address, unsigned char value)
{
	//$400C   --le nnnn   loop env/disable length, env disable, vol/env period
	//$400E   s--- pppp   short mode, period index
	//$400F   llll l---   length index
	switch (address - 0x4000)
	{
	case 0xC:
		length.set_halt((value & 0x20) >> 5);
		envelope.write(value);
		break;
	case 0xE:
		short_mode = value & 0x80; //1 = short
		random_period = random_period_table[value & 0xF];
		timer.set_period(random_period);
		break;
	case 0xF:
		length.set_length(value >> 3);
		envelope.reset_counter();
		break;
	}
}

void c_apu2::c_noise::clock_timer()
{
	timer.clock(0);
	if (timer.get_output())
	{
		int	feedback = (lfsr & 0x1) ^ ((lfsr >> (short_mode ? 6 : 1)) & 0x1);
		feedback <<= 14;
		lfsr = (lfsr >> 1) | feedback;
	}
}

void c_apu2::c_noise::clock_envelope()
{
	envelope.clock();
}

void c_apu2::c_noise::clock_length()
{
	length.clock();
}

int c_apu2::c_noise::get_output()
{
	if (!(lfsr & 0x1) && length.get_output())
	{	
		return envelope.get_output();
	}
	else
	{
		return 0;
	}
}

int c_apu2::c_noise::get_status()
{
	return length.get_counter() ? 1 : 0;
}

void c_apu2::c_noise::enable()
{
	length.enable();
}

void c_apu2::c_noise::disable()
{
	length.disable();
}

c_apu2::c_dmc::c_dmc()
{
	reset();
}

c_apu2::c_dmc::~c_dmc()
{
}

void c_apu2::c_dmc::reset()
{
	cycle = 1;
	silence = 1;
	output_shift = 0;
	output_counter = 0;
	sample_buffer_empty = 1;
	bits_remain = 1;
	duration = 0;
	enabled = 0;
	loop = 0;
	sample_address = 0;
	sample_length = 1;
	irq_enable = 0;
	irq_asserted = 0;
	irq_flag = 0;
	timer.reset();

}

int c_apu2::c_dmc::get_output()
{
	return output_counter;
}

const int c_apu2::c_dmc::freq_table[16] = {
	0x1AC, 0x17C, 0x154, 0x140, 0x11E, 0x0FE, 0x0E2, 0x0D6,
	0x0BE, 0x0A0, 0x08E, 0x080, 0x06A, 0x054, 0x048, 0x036
};

void c_apu2::c_dmc::write(unsigned short address, unsigned char value)
{
	//$4010   il-- ffff   IRQ enable, loop, frequency index
	//$4011   -ddd dddd   DAC
	//$4012   aaaa aaaa   sample address
	//$4013   llll llll   sample length
	switch (address - 0x4000)
	{
	case 0x10:
		loop = value & 0x40;
		irq_enable = value & 0x80;
		freq_index = value & 0xF;
		timer.set_period(freq_table[freq_index] - 1);
		if (!irq_asserted && irq_enable && irq_flag)
		{
			irq_asserted = 1;
			nes->cpu->execute_irq();
		}
		else if (!irq_enable)
		{
			if (irq_asserted)
			{
				irq_asserted = 0;
				nes->cpu->clear_irq();
			}
			irq_flag = 0;
		}
		break;
	case 0x11:
		output_counter = (value & 0x7F);
		break;
	case 0x12:
		sample_address = 0x4000 + value * 0x40;
		break;
	case 0x13:
		sample_length = value * 0x10 + 1;
		break;
	}
}

int c_apu2::c_dmc::get_status()
{
	return duration ? 1 : 0;
}

void c_apu2::c_dmc::clock_timer()
{
	timer.clock(0);
	if (timer.get_output())
	{
		if (!silence)
		{
			if (output_shift & 0x1)
			{
				if (output_counter < 126)
					output_counter += 2;
			}
			else 
			{
				if (output_counter > 1)
					output_counter -= 2;
			}
		}
		output_shift >>= 1;
		if (--bits_remain == 0)
		{
			bits_remain = 8;
			if (sample_buffer_empty)
			{
				silence = 1;
			}
			else
			{
				output_shift = sample_buffer;
				sample_buffer_empty = 1;
				fill_sample_buffer();
				silence = 0;
			}
		}
	}
}

void c_apu2::c_dmc::set_nes(c_nes *nes)
{
	this->nes = nes;

}

void c_apu2::c_dmc::enable()
{
	if (duration == 0)
	{
		address = sample_address;
		duration = sample_length;
		fill_sample_buffer();
		enabled = 1;
	}
}

void c_apu2::c_dmc::disable()
{
	duration = 0;
	enabled = 0;
	//disable irq?
	//ack_irq();
}

void c_apu2::c_dmc::ack_irq()
{
	irq_flag = 0;
	if (irq_asserted)
	{
		nes->cpu->clear_irq();
		irq_asserted = 0;
	}
}

void c_apu2::c_dmc::fill_sample_buffer()
{
	if (sample_buffer_empty && duration)
	{
		output_shift = nes->DmcRead(0x8000 + address);
		address = (address + 1) & 0x7FFF;
		sample_buffer_empty = 0;
		if (--duration == 0)
		{
			if (loop)
			{
				address = sample_address;
				duration = sample_length;
			}
			else
			{
				//enabled = 0;
				if (irq_enable)
				{
					irq_flag = 1;
					if (irq_flag && !irq_asserted)
					{
						nes->cpu->execute_irq();
						irq_asserted = 1;
					}
				}
				else
				{
					irq_flag = 0;
				}
			}
		}
	}
}

int c_apu2::c_dmc::get_irq_flag()
{
	return irq_flag ? 1 : 0;
}